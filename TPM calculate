# ==============================================================================
# 综合处理脚本：Counts分离 -> 长度计算 -> Symbol转换 -> TPM计算
# ==============================================================================

library(data.table)
library(dplyr)
library(rtracklayer)
library(GenomicRanges)

# ==============================
# 1. 参数与路径设置
# ==============================
# 输入文件
counts_file <- "KAT8_counts.csv"

# 注释文件路径 (WSL路径格式)
gene_gtf_path <- "\\\\wsl.localhost\\Ubuntu\\home\\qiuzerui\\annotationHv49\\gencode.v49.annotation_PRI.gtf"
te_gtf_path   <- "\\\\wsl.localhost\\Ubuntu\\home\\qiuzerui\\annotationHv49\\h38_TE.gtf"

# 输出文件
output_file <- "KAT8_final_counts_tpm.csv"

# ==============================
# 2. 读取并拆分 Counts 数据
# ==============================
message(paste0("[", Sys.time(), "] 正在读取 Counts 文件..."))
counts_df <- fread(counts_file)

# 拆分 Gene 和 TE
# 规则：Gene 以 ENSG 开头，TE 包含冒号
gene_counts <- counts_df[grep("^ENSG", counts_df$RepeatID), ]
te_counts   <- counts_df[grep(":", counts_df$RepeatID), ]

message(paste("   - 识别到 Gene 行数:", nrow(gene_counts)))
message(paste("   - 识别到 TE 行数:  ", nrow(te_counts)))

# ==============================
# 3. 处理 Gene 部分 (长度 + Symbol)
# ==============================
message(paste0("[", Sys.time(), "] 正在处理 Gene 注释 (这可能需要几分钟)..."))

# 3.1 读取 Gene GTF 并提取 Symbol
gene_gtf <- import(gene_gtf_path)
gene_map <- unique(as.data.frame(mcols(gene_gtf)[, c("gene_id", "gene_name")]))

# 3.2 计算 Gene 有效长度 (Union Exon Length)
gene_exons <- gene_gtf[gene_gtf$type == "exon"]
gene_exons_list <- split(gene_exons, mcols(gene_exons)$gene_id)
gene_widths <- sum(width(reduce(gene_exons_list)))

gene_len_df <- data.frame(
  gene_id = names(gene_widths),
  length = as.numeric(gene_widths),
  stringsAsFactors = FALSE
)

# 3.3 合并信息到 Gene Counts
# 合并长度
gene_counts_processed <- left_join(gene_counts, gene_len_df, by = c("RepeatID" = "gene_id"))
# 合并 Symbol
gene_counts_processed <- left_join(gene_counts_processed, gene_map, by = c("RepeatID" = "gene_id"))
# 转换 ID 为 Symbol
gene_counts_processed$RepeatID <- ifelse(
  !is.na(gene_counts_processed$gene_name), 
  gene_counts_processed$gene_name, 
  gene_counts_processed$RepeatID
)
gene_counts_processed$gene_name <- NULL

# ==============================
# 4. 处理 TE 部分 (长度)
# ==============================
message(paste0("[", Sys.time(), "] 正在处理 TE 注释..."))

# 4.1 读取 TE GTF
te_gtf <- import(te_gtf_path)

# 4.2 构建 TE 唯一 ID 并计算长度
te_mcols <- mcols(te_gtf)
te_ids <- paste(te_mcols$gene_id, te_mcols$family_id, te_mcols$class_id, sep = ":")
mcols(te_gtf)$te_unique_id <- te_ids

te_list <- split(te_gtf, mcols(te_gtf)$te_unique_id)
te_widths <- sum(width(reduce(te_list)))

te_len_df <- data.frame(
  te_id = names(te_widths),
  length = as.numeric(te_widths),
  stringsAsFactors = FALSE
)

# 4.3 合并长度到 TE Counts
te_counts_processed <- left_join(te_counts, te_len_df, by = c("RepeatID" = "te_id"))

# ==============================
# 5. 合并数据并计算 TPM
# ==============================
message(paste0("[", Sys.time(), "] 正在合并数据并计算 TPM..."))

# 5.1 上下合并
final_df <- rbind(gene_counts_processed, te_counts_processed)

# 5.2 移除长度缺失的行 (防止计算报错)
# 如果有 NA，TPM 也会变成 NA
na_count <- sum(is.na(final_df$length))
if (na_count > 0) {
  warning(paste("注意：移除", na_count, "行未匹配到长度的数据。"))
  final_df <- final_df[!is.na(final_df$length), ]
}

# 5.3 TPM 计算函数
calculate_tpm <- function(counts, lengths) {
  # 1. 计算 RPK: reads per kilobase
  rpk <- counts / (lengths / 1000)
  
  # 2. 计算 Scaling factor: sum(rpk) / 1,000,000
  # 注意：这里 sum(rpk) 是该样本所有基因+TE的总 RPK
  scaling_factor <- sum(rpk) / 1e6
  
  # 3. 计算 TPM
  tpm <- rpk / scaling_factor
  return(tpm)
}

# 识别样本列 (排除 RepeatID 和 length 列)
# 假设除了 RepeatID 和 length 之外的列都是样本 count 列
sample_cols <- setdiff(names(final_df), c("RepeatID", "length"))

message(paste("识别到样本列:", paste(sample_cols, collapse = ", ")))

# 对每一列样本计算 TPM
# 我们将 TPM 结果添加为新列，列名后缀为 _TPM
for (col in sample_cols) {
  tpm_col_name <- paste0(col, "_TPM")
  
  # 调用函数计算
  final_df[[tpm_col_name]] <- calculate_tpm(final_df[[col]], final_df$length)
}

# ==============================
# 6. 输出结果（优化版）
# ==============================

# --- 步骤 A: 验证 TPM 总和 ---
# 获取所有以 _TPM 结尾的列
tpm_cols <- grep("_TPM$", names(final_df), value = TRUE)

# 在 R 控制台打印每一列的和，您会看到它们应该是 1,000,000
message("正在验证 TPM 总和 (理论上应接近 1,000,000):")
print(colSums(final_df[, ..tpm_cols], na.rm = TRUE))

# --- 步骤 B: 格式化数据以适配 Excel ---
# 为了防止 Excel 识别错误，我们将 TPM 列保留 4 位小数
# 这样可以去除科学计数法 (e.g., 1.23e-05 -> 0.0000)
# 同时将数值转换为普通数字格式
for (col in tpm_cols) {
  # round() 会四舍五入，format() 确保不使用科学计数法
  final_df[[col]] <- round(final_df[[col]], 4)
}

# --- 步骤 C: 导出文件 ---
# 使用 write.csv 而不是 fwrite，因为 write.csv 对 Excel 的兼容性通常更好
# row.names = FALSE 表示不保存行号
write.csv(final_df, output_file, row.names = FALSE)

message("========================================================")
message(paste("处理完成！"))
message(paste("输出文件:", output_file))
message("提示：请在 Excel 中打开时，检查数字列是否靠右对齐（代表被识别为数字）。")
message("========================================================")==")
